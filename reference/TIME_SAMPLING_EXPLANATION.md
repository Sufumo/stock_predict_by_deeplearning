# 时间维度采样机制详解

## 📅 一、时间窗口采样策略

### 1.1 滑动窗口采样（步长为1）

在 `components/data_loader.py` 的 `prepare_sequences()` 方法中，使用**滑动窗口**方式从时间序列中提取样本：

```python
# 关键代码（第429-431行）
for i in range(len(data) - max_window - future_days + 1):
    # 提取序列：从位置i开始，取max_window长度的数据
    seq = data[i:i+max_window]
    
    # 计算未来收益率（用于标签）
    start_price = current_prices[i+max_window-1]      # 窗口最后一天的价格
    end_price = current_prices[i+max_window+future_days-1]  # 未来future_days天的价格
    future_return = (end_price - start_price) / start_price
```

### 1.2 采样参数

- **max_window = 80**：单个时间窗口长度（80天）
- **future_days = 30**：预测未来天数（30天）
- **步长 = 1**：每天滑动一次（**完全重叠**）

### 1.3 样本数量计算

对于长度为 `L` 的时间序列数据：

```
可生成的样本数 = L - max_window - future_days + 1
```

**示例（960天数据）**：
```
样本数 = 960 - 80 - 30 + 1 = 851个样本
```

## 🔄 二、具体采样示例

### 2.1 单个行业的时间窗口采样

假设某个行业有960天的数据（2021-2025年，约4年）：

```
原始数据索引: [0, 1, 2, ..., 959]  (共960天)
max_window = 80
future_days = 30
```

**生成的样本**：

| 样本索引 | 时间窗口 | 窗口范围 | 预测目标 |
|---------|---------|---------|---------|
| 0 | data[0:80] | 第0-79天 | 第80-109天的收益率 |
| 1 | data[1:81] | 第1-80天 | 第81-110天的收益率 |
| 2 | data[2:82] | 第2-81天 | 第82-111天的收益率 |
| ... | ... | ... | ... |
| 850 | data[850:930] | 第850-929天 | 第930-959天的收益率 |

**可视化示例**（前5个样本）：

```
时间轴: 0    10    20    30    40    50    60    70    80    90   100
        |----|----|----|----|----|----|----|----|----|----|----|
样本0:  [========窗口0========]  [预测区间]
样本1:   [========窗口1========]  [预测区间]
样本2:    [========窗口2========]  [预测区间]
样本3:     [========窗口3========]  [预测区间]
样本4:      [========窗口4========]  [预测区间]
```

### 2.2 窗口重叠情况

**重叠度**：
- 相邻窗口重叠 **79天**（除了第一个和最后一个窗口）
- 重叠率 = (80-1)/80 = **98.75%**

**为什么使用完全重叠？**
- ✅ 最大化样本数量：从960天生成851个样本
- ✅ 充分利用数据：每个时间点都被多次使用
- ✅ 增加训练数据：提高模型训练效果

**注意**：虽然窗口重叠，但每个样本的**预测目标不同**（未来30天的收益率），所以不是重复样本。

## 📊 三、多行业采样

### 3.1 采样流程

项目中有多个行业（例如86个行业），采样流程：

```python
# 伪代码
all_samples = []
for industry_idx, industry_name in enumerate(industry_list):
    data = load_industry_data(industry_name)  # 例如960天
    
    for i in range(len(data) - 80 - 30 + 1):
        seq = data[i:i+80]  # 80天窗口
        target = calculate_future_return(i)  # 未来30天收益率分位数
        
        all_samples.append({
            'sequence': seq,
            'target': target,
            'industry_idx': industry_idx
        })
```

### 3.2 总样本数计算

假设有 `N` 个行业，每个行业有 `L` 天数据：

```
总样本数 = N × (L - 80 - 30 + 1)
```

**示例**：
- 86个行业
- 每个行业960天数据
- 总样本数 = 86 × 851 = **73,186个样本**

### 3.3 样本的时间顺序

**重要**：所有样本按以下顺序排列：

1. **先按行业顺序**：行业0的所有样本 → 行业1的所有样本 → ...
2. **每个行业内按时间顺序**：样本0（最早）→ 样本1 → ... → 样本850（最晚）

```
样本索引:  0-850   851-1701  1702-2552  ...  (行业0)  (行业1)  (行业2)
时间顺序:  早 → 晚   早 → 晚    早 → 晚
```

## 🔀 四、训练/验证集划分

### 4.1 TimeSeriesKFold 划分策略

使用 `components/validator.py` 中的 `TimeSeriesKFold` 进行时间序列交叉验证：

```python
# 关键代码（第38-78行）
for fold in range(n_splits):
    val_start = first_train_end + fold * val_size
    val_end = val_start + val_size
    
    # 训练集：从开始到验证集开始
    train_indices = indices[:val_start]
    # 验证集：验证集范围
    val_indices = indices[val_start:val_end]
```

### 4.2 3折交叉验证示例

假设总样本数 = 73,186，`min_train_size=0.4`，`n_splits=3`：

```
总样本数: 73,186
min_train_size = 0.4 → 第一个训练集结束位置 = 29,274

Fold 1:
  训练集: [0, 29,274)          (29,274个样本，时间最早)
  验证集: [29,274, 44,911)     (14,637个样本)

Fold 2:
  训练集: [0, 44,911)          (44,911个样本，包含Fold1的训练+验证)
  验证集: [44,911, 60,548)     (14,637个样本)

Fold 3:
  训练集: [0, 60,548)          (60,548个样本)
  验证集: [60,548, 73,186)     (12,638个样本，剩余所有)
```

### 4.3 时间顺序保证

**关键特性**：
- ✅ **训练集时间早于验证集**：严格避免未来信息泄露
- ✅ **验证集不重叠**：每个fold的验证集是独立的
- ✅ **训练集累积增长**：后续fold的训练集包含前面的验证集

**时间线可视化**（单个行业851个样本）：

```
时间轴: 0    200    400    600    800    851
        |-----|-----|-----|-----|-----|
Fold 1: [训练集] [验证集]
Fold 2: [----训练集----] [验证集]
Fold 3: [--------训练集--------] [验证集]
```

## 📐 五、具体数值示例

### 5.1 960天数据的采样

**输入**：
- 数据长度：960天（2021-2025年）
- max_window：80天
- future_days：30天

**计算**：
```
可生成样本数 = 960 - 80 - 30 + 1 = 851个样本

样本0: 使用第0-79天数据，预测第80-109天的收益率
样本1: 使用第1-80天数据，预测第81-110天的收益率
...
样本850: 使用第850-929天数据，预测第930-959天的收益率
```

**时间对应关系**（假设2021年1月1日为第0天）：

| 样本索引 | 窗口起始日期 | 窗口结束日期 | 预测起始日期 | 预测结束日期 |
|---------|------------|------------|------------|------------|
| 0 | 2021-01-01 | 2021-03-21 | 2021-03-22 | 2021-04-21 |
| 1 | 2021-01-02 | 2021-03-22 | 2021-03-23 | 2021-04-22 |
| ... | ... | ... | ... | ... |
| 850 | 2024-12-02 | 2025-02-20 | 2025-02-21 | 2025-03-23 |

### 5.2 窗口重叠示例

**前3个样本的详细对比**：

```
样本0: [第0-79天]  → 预测第80-109天
样本1: [第1-80天]  → 预测第81-110天
样本2: [第2-81天]  → 预测第82-111天

重叠部分：
- 样本0和样本1：重叠第1-79天（79天）
- 样本1和样本2：重叠第2-80天（79天）
```

## ⚠️ 六、注意事项

### 6.1 数据泄露问题

**已避免**：
- ✅ 训练集和验证集按时间顺序划分
- ✅ 验证集时间晚于训练集
- ✅ 预测目标（未来30天收益率）在训练时不可见

**需要注意**：
- ⚠️ 窗口重叠可能导致数据泄露：相邻样本共享79天数据
- ⚠️ 但在时间序列交叉验证中，这是可以接受的，因为：
  - 每个样本的预测目标不同（不同时间段的未来收益率）
  - 训练/验证划分保证了时间顺序

### 6.2 样本独立性

**样本不完全独立**：
- 相邻样本共享79/80的数据
- 但预测目标不同（不同时间段的收益率）
- 在时间序列任务中，这是常见做法

### 6.3 内存和计算

**样本数量**：
- 单个行业：851个样本
- 86个行业：约73,186个样本
- 每个样本：80天 × 7特征 = 560个数值

**内存占用**（估算）：
```
序列数据: 73,186 × 80 × 7 × 4字节 ≈ 164 MB
标签数据: 73,186 × 4字节 ≈ 0.3 MB
总计: 约165 MB（未压缩）
```

## 📝 七、代码位置总结

| 功能 | 文件位置 | 关键代码行 |
|------|---------|-----------|
| 时间窗口采样 | `components/data_loader.py` | `prepare_sequences()` 第429-431行 |
| 样本数量计算 | `components/data_loader.py` | `prepare_sequences()` 第401行、第429行 |
| 训练/验证划分 | `components/validator.py` | `TimeSeriesKFold.split()` 第38-78行 |
| 数据加载 | `components/data_loader.py` | `IndustryDataset.__getitem__()` 第594行 |

## 🎓 八、总结

1. **采样方式**：滑动窗口，步长为1（完全重叠）
2. **窗口大小**：80天（max_window）
3. **预测目标**：未来30天收益率（future_days）
4. **样本数量**：`L - 80 - 30 + 1`（L为数据长度）
5. **时间顺序**：严格保持，训练集时间早于验证集
6. **重叠度**：相邻窗口重叠79天（98.75%）

**对于960天数据**：
- 可生成 **851个样本**
- 每个样本使用 **80天** 历史数据
- 预测 **未来30天** 的收益率分位数
- 相邻样本重叠 **79天**

